---
layout:     post
title:      Java多线程系列
subtitle:   可见性
date:       2018-04-25
author:     挨踢灰太狼
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
    - 多线程
---

何为可见性？
======
在多线程的世界里，每个线程都有自己的工作内存，里面存储着各种变量。线程方法中的局部变量不会有同步的问题。但是，不同线程之间的共享变量就不一定了。最典型的共享变量就是某个类的静态成员。对于这些共享变量，每个线程都会把共享变量拷贝一份副本，因为JVM只允许线程修改自己工作内存中的变量值。换言之，不同线程变量之间的传递必须经过主内存。如下图：
![JMM示意图](https://upload-images.jianshu.io/upload_images/9289152-df243a49fa7f7b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样一来，线程1如果修改了共享变量，线程2不一定能够看到。除非线程1在更新自己的副本之后，还能把线程副本中的新值写入到主内存中。同时，线程2能重新从主内存中刷新这个共享变量。

另外，还有一个现象就是**指令重排序**。它是编译器或处理器为了提高程序性能而做的优化。有如下几种：
- 编译器优化的重排序（编译器优化）
- 指令级并行重排序（处理器优化）
- 内存系统的重排序（处理器优化）

这个重排序会导致代码书写的顺序与实际执行顺序不同的现象。
重排序不会给单线程带来内存可见性的问题。但是，多线程中程序交错执行时，重排序可能会造成内存可见性问题。下图是《Java并发编程实践》中的一个例子，能说明可见性的问题。
![重排序的栗子](https://upload-images.jianshu.io/upload_images/9289152-08a510346b645883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

综上，多线程情况下，某个线程中变量值的修改可能在其他线程中看不到，这样的问题就是多线程下的可见性问题。
以下方法可以解决可见性问题。

1、synchronized加锁
======
JMM关于synchronized的两条规定：
- 线程解锁前，必须把共享变量的最新值刷新到主内存中。
- 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是**同一把锁**）。
如此一来，线程解锁前对共享变量的修改，其他线程可见。

2、volatile
======
- 禁止重排序优化来保证内存可见性。
- 及时刷新主内存的值。当对volatile变量执行写操作时，会在写操作后加入一条store屏障指令；当对volatile变量执行读操作时，会在读操作前加入一条load屏障指令。这样一写一读，保证了内存可见性。

## volatile关键字使用注意事项
- 不能保证volatile变量复合操作的原子性。
- 在多线程中安全的使用volatile变量必须同时满足三个条件：
1)对变量的写入操作不依赖其当前值，如number++不可以。或者能够确保只有单一的线程修改变量的值。
2)该变量没有包含在具有其他变量的不变式中，如果有多个volatile变量，则每个volatile变量必须独立于其他的volatile变量。
3)访问变量时，没有其他的原因需要加锁。

## synchronized和volatile之间的区别
- 加锁可以保证可见性和原子性，但是volatile只能保证可见性。
- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高。所以，如果能用volatile解决问题，还是应尽量使用volatile。


其他
======
- 即使没有保证可见性的措施，很多时候共享变量也能够在主内存和工作内存中得到及时的更新？
一般只有在短时间内高并发的情况下才会出现变量得不到及时更新的情况，因为CPU在执行时会很快的刷新缓存，所以一般情况下很难看到这种问题，而且也与硬件性能有很大的关系，所以，结果都是不可预测的。
- java中long、double是64位的，其读写会分成两次32位的操作，并不是原子操作，但很多商用虚拟机都进行了优化，所以，多线程编程时需要注意这两种类型值的处理。

参考文章
======
https://www.cnblogs.com/rocomp/p/4780532.html
Java并发编程实践



